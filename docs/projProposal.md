# Експертски систем за информациону безбедност

-   Филип Контић, SV 20/2020
-   Лазар Магазин, SV 25/2020

## Мотивација

Информациона безбедност је веома важна тема у савременом рачунарству. Скоро да не постоји софтвер који не комуницира преко интернета или који не приступа локалним подацима. Развој безбедног софтвера подразумева како дизајн и моделовање безбедносних захтева, тако и митигацију у случају пропуста. Ово је скупо и захтева много времена и људске експертизе.

По OWASP Top 10 листи се закључује да су најчешћи безбедносни пропусти тривијалне мане које инжењери занемарују из незнања или мањка времена. Међутим, штета коју изазове злоупотреба тих пропуста се прекасно детектује. Употребом система који аутоматски прати логове апликације и благовремено реагује на њих, било би могуће умањити последице напада на апликацију.

## Преглед проблема

Потребно је развити генеричну апликацију за куповину артикала. Платформа треба имати _secure auditing and logging_ помоћу којег се детектује сумњиво понашање корисника.

Сама платформа је неадекватно заштићена од нападача. Ово се огледа како у њеној архитектури тако и у њеним функционалностима. Идеја иза овога је да се безбедносна контрола и мониторинг уграде у саму апликацију. Тиме бисмо демонстрирали како би се експертски систем за безбедност интегрисао у производ који је развијен без размишљања о самој безбедности (нпр. стартап где је примарни фокус био да се што пре направи MVP).

Апликација по својој природи треба да стриктно сагледа акције корисника. Пријава корисника на систем, објављивање артикала на продају, куповина артикала, остављање рецензије, качење фајлова су неке од акција које се прате у систему и које корисник може злоупотребити.

Апликација би за сваку сумњиву радњу и контекст корисника (описаног IP адресом или корисничким налогом) давала "казнене бодове". Казнени бод представља напомену о
сумњивом понашању корисника и у себи укључује вредност бодова, тип акције и опис.
Казнени бод не гарантује да је корисник заиста покушао да злоупотреби систем, нити
се резултује казном. На основу сакупљених казнених бодова, корисник би био адекватно кажњен. У најгорим ситуацијама где се детектује опасност већих размера, апликација би привремено постала недоступна обичним корисницима.
Дакле, крајњи корисник нашег KBS-а чини администрација и/или део развојног тима који је задужен за безбедност.

Слична решења која смо пронашли пате од преуског домена применљивости [1] [2]. У данашње време су много популарнија решења заснована на техникама дубоког учења [3] [4]. Овакви производи су најчешће комерцијални [5].
Наше решење је засновано на онтолошком _if-then_ закључивању, отвореног је кода, и дизајнирано је да се може применити у веб апликацијама других домена.

## Методологија рада

Три корисничке улоге у софтверу су: непријављени корисник, корисник, администратор. 

Роле су: обични корисник, full корисник, обичан администратор и super администратор. Пријављени корисник има једну ролу.

**Непријављени корисници** могу да прегледају продавницу и детаље индивидуалних артикала. Такође им је омогућена регистрација и пријава на систем. Провера да ли је његова IP адреса блокирана.

**Пријављени корисници** могу да постављају артикле на продају (ово могу само одређени корисници који имају високе привилегије), купују артикле других корисника и да остављају коментаре на артикле. Корисник може да види историју купљених артикала. Корисник може да види своје личне податке и да мења своју лозинку.

**Администратори** имају увид у све кориснике у систему. Могу да мењају ролу другим корисницима (али не и себи). Додатно могу да виде све IP адресе које су тренутно блокиране, дужину трајања тог блокирања као и разлог зашто је та IP адреса блокирана. У сваком тренутку администратор може да уклони блок са IP адресе. Администратор може да види аларме који се дешавају у систему и да у реалном времену прати нове аларме. Администратор може аларм да означи као "обрађен" чиме се он "деактивира". Администратор има приступ извештајима система.

### Улази

Улазне податке уноси корисник током рада са апликацијом:

-   контекст захтева (симулира се, део је сваког захтева):
    -   IP адреса извора
    -   IP адреса дестинације
    -   Port извора
-   кориснички захев:
    -   регистрација корисника (име, презиме, имејл адреса, лозинка, профилна слика)
    -   пријава корисника (имејл адреса, лозинка)
    -   добављање артикала
    -   објава артикла (назив, опис, слика, цена)
    -   куповина артикла
    -   рецензија (артикал, коментар)
    -   измена лозинке (стара лозинка, нова лозинка)
-   администраторски захтев:
    -   добављање корисника
    -   измена роле корисника (корисник, рола)
    -   добављање блокираних IP адреса
    -   уклањање блока на IP адресу (IP adresa)
    -   добављање аларма
    -   уклањање аларма (UUID аларма)
    -   креирање извештаја

### Излази

-   казна (корисник, казнени бодови, тип)
-   предузета мера:
    -   активација аларма
    -   одбијање захтева
    -   блокирање IP адресе
-   подаци из базе података и базе знања (када се добављају подаци)

### База знања

База знања је сачињена од продукционих правила везаних за безбедност веб апликација. Правила су писана ручно, од којих су нека параметризована и праве се преко шаблона.

Корисници преко интеракције са апликацијом попуњавају радну меморију чињеницама и догађајима. Систем евалуира правила и на основу њих окида правила која производе нове чињенице или извршавају пословну логику.

#### Правила

1. Ако систем прими захтев ван интерне мреже система на порту који није 5173, огласити аларм за напад на CORS.

1. Ако се деси много неуспелих пријава на исти налог са исте IP адресе, запиши казну тој IP адреси.
2. Ако се IP адреса казни превише пута због лоше аутентификације, блокирај је на неко време.
3. Ако се превише IP адреса блокира због аутентификације, огласити аларм за напад на аутентификацију.

1. Ако се превише налога улогује са истом лозинком, означи лозинку као слабу.
2. Ако се корисник улогује са слабом лозинком, обавести га да промени лозинку.
3. Ако корисник покуша да промени лозинку на слабу лозинку, спречи га у томе.
4. Ако се у систему налази велики број слабих лозинки, огласити аларм.

1. Ако админ пошаље захтев за уклањање аларма, уклони аларм.
2. Ако админ пошаље захтев за уклањање аларма који не постоји, игнориши захтев.

1. Када систем покрене уклањање истеклих блокова на IP адресу, уклони све IP адресе које су истекле пре тренутног времена.
2. Када систем покрене уклањање истеклих блокова на IP адресу, ако не постоји истеклих блокова, игнориши.
3. Ако админ пошаље захтев за одблокирање IP адресе, уклони блок.
4. Ако админ пошаље захтев за одблокирање IP адресе која није блокирана, игнориши.
5. Ако је IP адреса блокирана, одбаци захтев са те IP адресе.

1. Ако се много захтева са исте IP адресе деси у кратком времену, запиши казну на ту IP адресу.

1. Ако се деси велик број захтева где су изворна и одредишна IP адреса исти, огласи аларм за TCP flood DOS напад.

1. Ако се пошаље изазов за ауторизацију корисника U за пермисију P, и корисник U нема пермисију U, одбиј захтев.

1. Ако се пошаље захтев у којем је текстуални садржај облика "; or 1=1", записати казну кориснику и огласи injection напад.
2. Ako ista IP адреса буде кажњена довољно пута због инјекције, блокирај је на неко време.

1. Ако се деси један напад критичког нивоа, огласи аларм.
2. Ако се десе два различита напада веома високог нивоа (или горег), огласи аларм.
3. Ако се десе четири различита напада, огласи аларм.

1. Ако се деси велик број захтева у јединици времена из барем N различитих IP адреса, огласи DDOS напад.

1. Ако се деси белик број захтева у јединици времена из једне IP адресе, огласи DOS напад.

1. Ако има више од 3 напада типа "Аутентификација" у последња 24 сата, додај напад у листу

1. Ако има више од 3 напада било ког типа у последња 24 сата, додај напад у листу

1. Ако има више од 3 неуспела покушаја логина са исте адресе у последња 24 сата, додај покушај у листу

1. Ако има више од 3 блок догађаја са исте адресе у последња 24 сата, додај догађај у листу

#### Forward Chaining

Испод су дата два примера forward chaining-а. У систему постоји много комбинација правила која се међусобно уланчавају (јер су све догађаји), те постоји и више forward chaining токова.

**Ланац 1**

```
1. Када се превише често деси неуспели login на исти налог са једне IP адресе, IP адреса је кажњена.
2. Ако је IP адреса често кажњена због неуспеле аутентификације, она бива блокирана.
3. Ако је много IP адреса блокирано због напада на аутентификацију, огласи аларм о нападу на аутентификацију.
4. Ако администратор пошаље догађај за брисање аларма који постоји у бази знања, уклонити га.
```

**Ланац 2**

```
1. Ако се детектује кориснички унос текста облика `; or 1=1;`, казни корисника да покушава урадити SQL инјекцију и детектуј то као напад
2. Ако је иста IP адреса кажњена више пута због SQL инјекције, блокирај је.
3. Ако администратор пошаље догађај за брисање блока на IP адресу, уклони блок.
```

#### Backward Chaining


Хијерархијски RBAC: Сваки endpoint зависи од једне (или потенцијално више)
пермисија које мора имати корисник који шаље захтев. Улога има ниједну или више
пермисија. Улога може имати највише једну улогу као родитеља, при чему она
наслеђује пермисије родитељске улоге. Сваки корисник има једну улогу.
Неаутентификовани корисник нема улогу.

Пример стабла:

```
            [Full user]                           | < Рола
           /           \                          | 
       [User]           \                         | < Рола
       /                 \                        | 
 (Купи артикал)     (Стави артикал на продају)    | < Пермисија
```

Пример уланчавања уназад:

```ruby
declare Role {
    id: int
    name: string,
    permissions: Permission[],
    parent: Role
}

declare Permission {
    id: int,
    name: string
}

declare User {
    ...,
    role: Role
}

query RoleHasPermission(role: Role, permission: Permission) {
    Role(id == $role.id, $permissions: permissions)
    Permission(id == $permission.id, this in $permissions)
    or
    $parentRole: Role($role.parent == this)
    RoleHasPermission($rparentRole, $permission)
}

query UserHasPermission(user: User, permission: Permission) {
    User(id == user.id, $role: role)
    RoleHasPermission($role, $permission)
}
```

Пример употребе уланчавања уназад у правилима:

```ruby
class RbacQuery {
    user: User,
    permission: Permission,
    granted: Bool
}

rule "Check access for user"
when
    $q: RbacQuery($user: user, $permission: permission)
    !UserHasPermission($user, $permission)
then
    $q.granted = false;
end
```

Употреба у коду:

```java
void preAuthorize2(String permissionName) {
    User user = authFacade.getUser();
    Permission permission = permissionService.findByName(permissionName);

    RbacQuery query = new RbacQuery(user, permission);
    ksession.insert(query);
    ksession.fireAllRules();

    if (query.granted == false) {
        throw UnauthorizedException();
    }
}

@Post("/user/ban?userId")
void banUser(Long userId) {
    preAuthorize2("ban_users");
    ...
}
```

#### CEP

Горенаведене чињенице (захтев, блок IP адресе, аларм, напад итд.) су догађаји. Испод су дата два примера обраде правила на финијем нивоу где је приказан CEP. У оба случаја је дат исечак кода самог правила, али су неки делови правила изостављени ради прегледности.

**CEP 1**

```ruby
rule "Детекција слабе лозинке"
when
    LoginEvent($thePassword: password)
    Set(size >= 2) from accumulate(
        LoginEvent(
            $email: email,
            password == $thePassword
        ) over window:time(6h),
        collectSet($email)
    )
    not WeakPassword(password == $thePassword);
then
    insert(new WeakPassword($thePassword));
end
```

**CEP 2**

```ruby
rule "Блокирање IP адресе због SQL инјекције"
when
    $n: Note(
        $ip: ip, 
        $type: type,
        $type == NoteType.INJECTION,
        usedInBlock == false
    )
    Number(intValue >= 25) from accumulate(
        Note(
            $ip == ip,
            $points: points,
            $type == type,
            usedInBlock == false
        ) over window:time(30m),
        sum($points)
    )
then
    insert(new BlockEvent($ip, 30 * 60 * 1000L, BlockReason INJECTION));
end
```

#### Template

**Template 1**

Извештаји. Параметри су следећи:
- `attackType`: Врста напада у извештају специфичног напада. Подразумевано `AttackType.AUTHENTICATION`.
- `num`: Број догађаја потребан да се извештај окине. Подразумевано 3.

```ruby
rule "Show attack events of type @{attackType} in last 24 hours if there is more than ${num} of them"
    no-loop
    when
        $req: ReportRequest(reportName == "attackEventSpecific")
        $e1: AttackEvent(type == @{attackType}) over window:time(24h)
        reportAttackEventOver24h($e1, @{num}-1;)
    then
        modify($req) {
            addResult($e1.toString());
        }
end

rule "Show attack events of all types in last 24 hours if there is more than @{num} of them"
    no-loop
    when
        $req: ReportRequest(reportName == "attackEventAll")
        $e1: AttackEvent() over window:time(24h)
        reportAnyAttackEventOver24h($e1, @{num}-1;)
    then
        modify($req) {
            addResult($e1.toString());
        }
end

rule "Show failed login attempts from same ip address in last 24 hours if there is more than @{num} of them"
    no-loop
    when
        $req: ReportRequest(reportName == "failedLogin")
        $e1: FailedLoginEvent($ip: ip) over window:time(24h)
        reportFailedLoginEventOver24h($e1, @{num}-1;)
    then
        modify($req) {
            addResult($e1.toString());
        }
end

rule "Show block events for same ip address in last 24 hours if there is more than @{num} of them"
    no-loop
    when
        $req: ReportRequest(reportName == "blockEvent")
        $e1: BlockEvent($ip: ip) over window:time(24h)
        reportBlockEventOver24h($e1, @{num}-1;)
    then
        modify($req) {
            addResult($e1.toString());
        }
end
```

**Template 2**

Детекције DOS напада. Прати се број захтева у јединици времена са исте IP адресе, и у случају да систем није скоро под DOS/DDOS нападом, оглашава се аларм о DOS нападу. Испод је дат псеудокод.

```ruby
when
    count(
        accumulate(
            Request(same(ip))
        ) over window:time(@timeFrame)
    ) > @numberOfRequests
then
    insert(new DOSAttack())
```

Параметри `timeFrame` и `numberOfRequests` се учитавају из `.xlsl` табеле.

**Template 3**

Детекције DDOS напада. Прати се број захтева у јединици времена са неколико IP адреса, и у случају да систем није скоро под DOS/DDOS нападом, оглашава се аларм о DDOS нападу. Испод је дат псеудокод.

```ruby
when
    count(
        accumulate(
            Request(same(ip))
        ) over window:time(@timeFrame)
    ) > @numberOfRequests
    count(
        accumulate(
            Request($ip)
        ) over window:time(@timeFrame)
    ) > @minimumNumberOfUniqueIPs
then
    insert(new DDOSAttack())
```

Параметри `timeFrame`, `numberOfRequests` и `minimumNumberOfUniqueIPs` се учитавају из `.xlsl` табеле.

#### Query

Поред упита у backward chaining и у извештајима, постоје и следећи упити:
- добављање свих активних аларма
- добављање свих IP адреса која су блокиране

## Пример резоновања

TODO: Навести неки пример.

## Литература

[1] Rajput, Quratulain, et al. "Ontology based expert-system for suspicious transactions detection." Computer and Information Science 7.1 (2014): 103.

[2] Zhang, Guo-Yin, Jian Li, and Guo-Chang Gu. "Research on defending DDoS attack-an expert system approach." 2004 IEEE International Conference on Systems, Man and Cybernetics (IEEE Cat. No. 04CH37583). Vol. 4. IEEE, 2004.

[3] Niyaz, Quamar, Weiqing Sun, and Ahmad Y. Javaid. "A deep learning based DDoS detection system in software-defined networking (SDN)." arXiv preprint arXiv:1611.07400 (2016).

[4] Naomi, J. Fenila, et al. "Intelligent transaction system for fraud detection using deep learning networks." Journal of Physics: Conference Series. Vol. 1916. No. 1. IOP Publishing, 2021.

[5] https://youverify.co/, Датум приступа: 18.4.2024.

[/] https://www.piranirisk.com/blog/how-to-identify-unusual-or-suspicious-transactions, Датум приступа: 19.4.2024.

[/] https://www.notiones.eu/2023/07/13/use-of-expert-systems-in-cyber-defense/, Датум приступа: 19.4.2024.
